Optimizable Agent-Based Simulations=====================================## IntroductionThe goal of this language is to define a human-editable statechart description format.It is particularly intended for biologists and chemist that need to describe systems at a agent-based level, want high-performance simulations but do not want to be limited by the possibilities of the simulation or have to deal with code themselves. It is therefore inspired but different from SBML.## Similarities with SBMLLike in SBML, objects live in sets (the equivalent of compartments). Sets contain different states in various amounts, and those population can evolve over time. Like in SBML, reactions can transform a group of producers states into a group of products. Finally, the rate at which those reactions occur can be defined using abribtrary mathematical expressions (but those can be written as normal formulas, and not as MathML).## Differences with SBMLUnlike SBML, OABS has the notion of substates. Example: a MilitaryUnit can either be (WithHorse / WithoutHorse), (WithBow / WithSword), (Green / Experienced / VeryExperienced). Representing such combinations without substates would required `2*2*3` = 12 states in SBML but can be factorized into one in OABS. Transitions that apply to all such states do not have to be repeated 12 times, which would be a waste of time.	new TCell=		new State(			Function=				some TCellFunction			Age=				some TCellAge		)This means that an object can be composed of various subproperties which can influence their behavior. Substates can influence the behavior of an object by serving as guards for reactions and transitions, by providing coefficients used in transition rates, or by providing other substates to use as transition target.	DestroyUndefendedFortress=		new Reaction(			From=   [ some Fortress(DefenseState=NotProtected, AttackState=Attacked) as x ]			To=     [ ]			Rate=   0.5		)Because substates can also take numeric values, the number of states that can be possibly generated is potentially unbounded. An example of unbounded state potential could be a Cell with an Age property that would be a number, and be incremented by one every time it is cloned. The age could then be used in the cloning rate of the cell. The expressivity gained here is enourmous. Firstly, you can get an infinite number of states, but you can also get non-integer-valued states, which allow for more precision.	new LocatedObject=		new State(			X = some number			Y = some number		)Transitions differ from reactions in the sense they conserve the number of states, and can therefore be used for substates. In our MilitaryUnit example, they would explain how a Green unit could become Experienced, for instance. This transition may share common properties 	NaiveDifferentiation=		new Transition(			From= Naive			To=   Effective			Rate= ...		)OABS supports pattern matching which allows to control whenever transitions or reactions apply very precisely. Destination states of transitions and reactions can be defined by copying arbitrarily information from the previous states, or incorporating computations or new values.	ProliferationByDefense=		new Reaction(			From=				[					some AttackDefense(DefenseState=Protected, AttackState=NotAttacked)				]			To=				[					1 new[x]()					1 new[x](DefenseState=NotProtected)				]			Rate=				0.5		)To the contrary of SBML which will need to execute the transitions to all possibles variants of a state, OABS will only work on variants that actually exist. This is actually necessary as the number of existing states can be unbounded (but the actual number of different states is bounded by the branching factor of the simulation and execution time).Finally, OABS use a text-based format that's easily readable and writable by humans, as opposed to XML and MathML which are complex to write and reserved to machines.## Advantages over SBMLThe languages supports things similar to templates, and allows for code reuse between models. Because it encourages encapsulation, it enables model combinations, which can improve the state of the art of simulation.Because it enables nested states, it is also more readable and decomposes the problems into smaller entities, enabling to fine tune each submodel independently by trying hypothesis in a relatively independent manner.By allowing unbounded numerical values as states, it also open the doors to other kinds of simulations where agents live in an open world.Finally, the file format is much more readable, and you don't need to train yourself to understand the models developed by someone else.